name: Docker Image CI

on:
  workflow_call:
    inputs:
      environment_tag:
        description: Environment of the deployment
        required: false
        type: string
      docker_compose_file_csv_list:
        description: The path of the compose.yaml file needed to build docker images
        required: true
        type: string
      function_app_source_code_path:
        description: The source path of the function app source code for the docker builds
        required: true
        type: string
      project_name:
        description: The name of the project
        required: true
        type: string
      excluded_containers_csv_list:
        description: Excluded containers in a comma separated list
        required: true
        type: string
      changed_folders:
        description: A comma-separated list of folders deemed to have "changed"
        required: false
        type: string

env:
  ACR_NAME: ${{ secrets.ACR_NAME }}
  COMPOSE_FILE: ${{ inputs.docker_compose_file_csv_list }}
  ENVIRONMENT_TAG: ${{ inputs.environment_tag }}
  PROJECT_NAME: ${{ inputs.project_name }}
  USE_AZURECR: ${{ secrets.ACR_NAME != '' }}
  IS_TEST_DEPLOY: true

jobs:
  containers-to-build:
    name: Containers to build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      id-token: write
    outputs:
      containers: ${{ steps.get-function-names.outputs.FUNC_NAMES }}
      docker_services: ${{ steps.get-function-names.outputs.ALL_SERVICES }}
      docker_compose_dir: ${{ steps.get-function-names.outputs.DOCKER_COMPOSE_DIR }}
      pr_num_tag: ${{ steps.tags.outputs.pr_num_tag }}
      short_commit_hash: ${{ steps.tags.outputs.short_commit_hash }}
    steps:
      - uses: actions/checkout@v4
        with:
          # to allow git diff between HEAD and the previous commit to main branch
          fetch-depth: 2

      - name: Checkout dtos-devops-templates repository
        uses: actions/checkout@v4
        with:
          repository: NHSDigital/dtos-devops-templates
          path: templates
          ref: dev-dtoss-8958

      - name: Determine which Docker container(s) to build
        id: get-function-names
        env:
          CHANGED_FOLDERS_CSV: ${{ inputs.changed_folders }}
          COMPOSE_FILES_CSV: ${{ inputs.docker_compose_file_csv_list }}
          EXCLUDED_CONTAINERS_CSV: ${{ inputs.excluded_containers_csv_list }}
          SOURCE_CODE_PATH: ${{ inputs.function_app_source_code_path }}
        run: bash ./templates/scripts/deployments/get-docker-names.sh

      - name: Fetch tag metadata
        id: tags
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"

          if [ -z "$PR_NUMBER" ]; then
            echo "Looking up PR number for commit: $GITHUB_SHA"
            PR_NUMBER=$(gh pr list --state open --search "$GITHUB_SHA" --json number -q '.[0].number' 2>/dev/null || true)
          fi

          if [ -z "$PR_NUMBER" ]; then
            PR_NUMBER=$(gh pr list --state merged --search "$GITHUB_SHA" --json number -q '.[0].number' 2>/dev/null || true)
          fi

          set -x
          [[ "${GITHUB_REF}" == "refs/heads/main" ]] && PR_NUMBER=$(gh api repos/{owner}/{repo}/commits/${GITHUB_SHA}/pulls --jq 'sort_by(.updated_at) | reverse | .[0].number')

          echo "Resolved PR number: ${PR_NUMBER}"
          echo "pr_num_tag=pr${PR_NUMBER}" >> "${GITHUB_OUTPUT}"
          echo "short_commit_hash=$(git rev-parse --short ${GITHUB_SHA})" >> "${GITHUB_OUTPUT}"

  build-and-push:
    name: Docker build and push
    if: needs.containers-to-build.outputs.containers != '[]'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
      pull-requests: read
      packages: write
    outputs:
      test_deployment: ${{ steps.docker_image.outputs.is_test_deploy }}
    needs: containers-to-build
    strategy:
      fail-fast: false
      matrix:
        function: ${{ fromJSON(needs.containers-to-build.outputs.containers) }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
          submodules: true

      - name: Checkout dtos-devops-templates
        uses: actions/checkout@v4
        with:
          repository: NHSDigital/dtos-devops-templates
          path: templates
          ref: dev-dtoss-8958

      - name: Build Docker image
        id: docker_image
        working-directory: ${{ needs.containers-to-build.outputs.docker_compose_dir }}
        continue-on-error: false
        env:
          IMAGE_NAME: ${{ inputs.project_name }}-${{ matrix.function }}
          PR_NUM_TAG: ${{ needs.containers-to-build.outputs.pr_num_tag }}
          SHORT_COMMIT_HASH: ${{ needs.containers-to-build.outputs.short_commit_hash }}
          REGISTRY: ${{ env.USE_AZURECR == 'true' && format('{0}.azurecr.io', secrets.ACR_NAME) || format('ghcr.io/{0}', github.repository_owner) }}
          TEST_DEPLOY: ${{ env.IS_TEST_DEPLOY }}
        run: |
          echo "is_test_deploy=${TEST_DEPLOY}" >> "${GITHUB_OUTPUT}"

          repository_path="${REGISTRY,,}/${IMAGE_NAME}"
          echo "repository_path=${repository_path}" >> "${GITHUB_OUTPUT}"
          echo repository_path=${repository_path}

          echo Docker compose...
          docker compose -f ${COMPOSE_FILE//,/ -f } -p ${PROJECT_NAME} build --no-cache --pull ${{ matrix.function }}

          echo "Docker tag with tags (${PR_NUM_TAG}, ${SHORT_COMMIT_HASH})..."
          docker tag ${IMAGE_NAME}:latest "${repository_path}:${PR_NUM_TAG}"
          #docker tag ${IMAGE_NAME}:latest "${repository_path}:${SHORT_COMMIT_HASH}"
          [[ -n "${ENVIRONMENT_TAG}" ]] && docker tag "${IMAGE_NAME}:latest" "${repository_path}:${ENVIRONMENT_TAG}"

      - name: AzureCLI login
        if: github.ref == 'refs/heads/main' && env.USE_AZURECR == 'true'
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ghcr.io login
        if: (github.ref == 'refs/heads/main' && env.USE_AZURECR == 'false') || env.IS_TEST_DEPLOY == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Push Docker image
        if: github.ref == 'refs/heads/main' || env.IS_TEST_DEPLOY == 'true'
        working-directory: ${{ needs.containers-to-build.outputs.docker_compose_dir }}
        continue-on-error: false
        env:
          PR_NUM_TAG: ${{ needs.containers-to-build.outputs.pr_num_tag }}
          REPO_PATH: ${{ steps.docker_image.outputs.repository_path }}
          SHORT_COMMIT_HASH: ${{ needs.containers-to-build.outputs.short_commit_hash }}
        run: |
          [[ "${USE_AZURECR}" == "true" ]] && az acr login --name "${ACR_NAME}"
          [[ -n "${ENVIRONMENT_TAG}" ]] && docker push "${REPO_PATH}:${ENVIRONMENT_TAG}"
          docker push "${REPO_PATH}:${PR_NUM_TAG}"
          #docker push "${REPO_PATH}:${SHORT_COMMIT_HASH}"

      - name: Software Bill of Materials (SBOM)
        id: sbom
        uses: ./templates/.github/actions/create-sbom-report
        with:
          image_name: ${{ inputs.project_name }}-${{ matrix.function }}

      - name: Vulnerability scan
        uses: ./templates/.github/actions/scan-vulnerabilities
        with:
          sbom_repository_report: ${{ steps.sbom.outputs.sbom_repository_report }}
          image_name: ${{ inputs.project_name }}-${{ matrix.function }}

  tag-all-repositories:
    name: Merge commit tag all images
    if: github.ref == 'refs/heads/main' || needs.build-and-push.outputs.test_deployment
    runs-on: ubuntu-latest
    needs: [build-and-push, containers-to-build]
    env:
      PR_NUM_TAG: ${{ needs.containers-to-build.outputs.pr_num_tag }}
      SHORT_COMMIT_HASH: ${{ needs.containers-to-build.outputs.short_commit_hash }}
    permissions:
      id-token: write
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
        with:
          # to allow git diff between HEAD and the previous commit to main branch
          fetch-depth: 2

      - name: Checkout dtos-devops-templates repository
        uses: actions/checkout@v4
        with:
          repository: NHSDigital/dtos-devops-templates
          path: templates
          ref: dev-dtoss-8958

      - name: AzureCLI login
        if: env.USE_AZURECR == 'true'
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ghcr.io login
        if: env.USE_AZURECR == 'false' || env.IS_TEST_DEPLOY == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Tag all azurecr.io Docker images
        if: env.USE_AZURECR == 'true'
        run: |
          wait_for_completion() {
            # acr tasks are backgrounded for parallelism
            local -n arr=$1
            for pid in "${arr[@]}"; do
              wait ${pid}
            done
          }
          pids=()
          az acr login --name "${ACR_NAME}"
          repositories=$(az acr repository list --name ${ACR_NAME} --output tsv)
          for repository in ${repositories}; do
            echo "Adding tag ${repository}:${SHORT_COMMIT_HASH}..."
            az acr import --name ${ACR_NAME} --source "${ACR_NAME}.azurecr.io/${repository}:${PR_NUM_TAG}" --image "${repository}:${SHORT_COMMIT_HASH}" --force &
            pids+=($!)
          done
          wait_for_completion pids

      - name: Tag all ghcr.io Docker images
        if: env.USE_AZURECR == 'false' || env.IS_TEST_DEPLOY == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          REGISTRY: ghcr.io/${{ github.repository_owner }}
          docker_services: ${{ needs.containers-to-build.outputs.docker_services }}
          PROJECT_NAME: ${{ inputs.project_name }}
        run: |
          echo Running 'docker buildx imagetools' on remote repositories...

          services=($(echo "$docker_services" | jq -r '.[]'))
          for service in "${services[@]}"; do
            image_name="${PROJECT_NAME}-${service}"
            echo "Adding tag ${SHORT_COMMIT_HASH} to ${image_name}..."
            docker buildx imagetools create "${REGISTRY,,}/${image_name,,}:${PR_NUM_TAG}" --tag "${REGISTRY,,}/${image_name,,}:${SHORT_COMMIT_HASH}" || echo "Tagging failed for $service"
          done

  aggregate-reports:
    name: Aggregate reports
    runs-on: ubuntu-latest
    needs: [build-and-push, containers-to-build]
    env:
      PR_NUM_TAG: ${{ needs.containers-to-build.outputs.pr_num_tag }}
    steps:
      - name: Get all artifacts
        uses: actions/download-artifact@v4
        with:
          path: reports-${{ needs.containers-to-build.outputs.pr_num_tag }}

      - name: Aggregate reports
        uses: actions/upload-artifact@v4
        with:
          name: aggregated-reports-${{ needs.containers-to-build.outputs.pr_num_tag }}
          path: reports-${{ needs.containers-to-build.outputs.pr_num_tag }}
