name: Docker Image CI

on:
  push:
    branches:
      - main

  workflow_call:
    inputs:
      environment_tag:
        description: Environment of the deployment
        required: true
        type: string
        default: development
      docker_compose_file_csv_list:
        description: The path of the compose.yaml file needed to build docker images
        required: true
        type: string
      function_app_source_code_path:
        description: The source path of the function app source code for the docker builds
        required: true
        type: string
      project_name:
        description: The name of the project
        required: true
        type: string
      excluded_containers_csv_list:
        description: Excluded containers in a comma separated list
        required: true
        type: string
      changed_folders:
        description: A comma-separated list of folders deemed to have "changed"
        required: false
        type: string

env:
  COMPOSE_FILE: ${{ inputs.docker_compose_file_csv_list }}
  PROJECT_NAME: ${{ inputs.project_name }}
  USE_AZURECR: ${{ secrets.ACR_NAME != '' }}
  ACR_NAME: ${{ secrets.ACR_NAME }}

jobs:
  get-functions:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      id-token: write
    outputs:
      FUNC_NAMES: ${{ steps.get-function-names.outputs.FUNC_NAMES }}
    steps:
      - uses: actions/checkout@v4
        with:
          # to allow git diff between HEAD and the previous commit to main branch
          fetch-depth: 2

      - name: Checkout dtos-devops-templates repository
        uses: actions/checkout@v4
        with:
          repository: NHSDigital/dtos-devops-templates
          path: templates
          ref: fix/function-app-acr-is-optional

      - name: Determine which Docker container(s) to build
        id: get-function-names
        env:
          COMPOSE_FILES_CSV: ${{ inputs.docker_compose_file_csv_list }}
          EXCLUDED_CONTAINERS_CSV: ${{ inputs.excluded_containers_csv_list }}
          SOURCE_CODE_PATH: ${{ inputs.function_app_source_code_path }}
          CHANGED_FOLDERS_CSV: ${{ inputs.changed_folders }}
        run: bash ./templates/scripts/deployments/get-docker-names.sh

  build-and-push:
    if: needs.get-functions.outputs.FUNC_NAMES != '[]'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
      pull-requests: read
      packages: write
    needs: get-functions
    strategy:
      fail-fast: false
      matrix:
        function: ${{ fromJSON(needs.get-functions.outputs.FUNC_NAMES) }}
    outputs:
      pr_num_tag: ${{ steps.tags.outputs.pr_num_tag }}
      short_commit_hash: ${{ steps.tags.outputs.short_commit_hash }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
          submodules: true

      - name: Checkout dtos-devops-templates
        uses: actions/checkout@v4
        with:
          repository: NHSDigital/dtos-devops-templates
          path: templates
          ref: fix/function-app-acr-is-optional

      - name: Create image tags
        id: tags
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REGISTRY: ${{ env.USE_AZURECR == 'true' && format('{0}.azurecr.io', secrets.ACR_NAME) || format('ghcr.io/{0}', github.repository_owner) }}
        run: |
          set -x
          [[ "${GITHUB_REF}" == "refs/heads/main" ]] && PR_NUMBER=$(gh api repos/{owner}/{repo}/commits/${GITHUB_SHA}/pulls --jq 'sort_by(.updated_at) | reverse | .[0].number')
          {
            echo "pr_num_tag=pr${PR_NUMBER}"
            echo "short_commit_hash=$(git rev-parse --short ${GITHUB_SHA})"
            echo "registry_repository_path=${REGISTRY,,}/${PROJECT_NAME,,}-${{ matrix.function }}"
          } >> "${GITHUB_OUTPUT}"

      - name: Build Docker image
        working-directory: ${{ steps.get-function-names.outputs.DOCKER_COMPOSE_DIR }}
        continue-on-error: false
        env:
          PR_NUM_TAG: ${{ steps.tags.outputs.pr_num_tag }}
          IMAGE_NAME: ${{ inputs.project_name }}-${{ matrix.function }}
          REPO_PATH: ${{ steps.tags.outputs.registry_repository_path }}
        run: |
          docker compose -f ${COMPOSE_FILE//,/ -f } -p ${PROJECT_NAME} build --no-cache --pull ${{ matrix.function }}
          docker tag ${IMAGE_NAME}:latest "${REPO_PATH}:${PR_NUM_TAG}"

      - name: AzureCLI login
        if: github.ref == 'refs/heads/main' && env.USE_AZURECR == 'true'
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ghcr.io login
        if: github.ref == 'refs/heads/main' && env.USE_AZURECR == 'false'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Push Docker image
        if: github.ref == 'refs/heads/main'
        working-directory: ${{ steps.get-function-names.outputs.DOCKER_COMPOSE_DIR }}
        continue-on-error: false
        env:
          PR_NUM_TAG: ${{ steps.tags.outputs.pr_num_tag }}
          REPO_PATH: ${{ steps.tags.outputs.registry_repository_path }}
          GH_TOKEN: ${{ github.token }}
        run: |
          [[ "${USE_AZURECR}" == "true" ]] && az acr login --name "${ACR_NAME}"
          docker push "${REPO_PATH}:${PR_NUM_TAG}"

      - name: List top-level folders
        run: |
          echo "Folders in the current directory:"
          find . -type d ! -name '.' | sort

      - name: Software Bill of Materials (SBOM)
        id: sbom
        uses: ./.github/actions/create-sbom-report
        with:
          project_name: ${{ inputs.project_name }}
          image_name: ${{ inputs.project_name }}-${{ matrix.function }}

      - name: Vulnerability scan
        uses: ./.github/actions/scan-vulnerabilities
        with:
          sbom_repository_report: ${{ steps.sbom.outputs.sbom_repository_report }}
          project_name: ${{ inputs.project_name }}
          image_name: ${{ inputs.project_name }}-${{ matrix.function }}

  tag-all-repositories:
    name: Add merge commit tag to all images
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: build-and-push
    env:
      PR_NUM_TAG: ${{ needs.build-and-push.outputs.pr_num_tag }}
      SHORT_COMMIT_HASH: ${{ needs.build-and-push.outputs.short_commit_hash }}
    permissions:
      id-token: write
      packages: write
    steps:
      - uses: actions/checkout@v4
        with:
          # to allow git diff between HEAD and the previous commit to main branch
          fetch-depth: 2

      - name: Checkout dtos-devops-templates repository
        uses: actions/checkout@v4
        with:
          repository: NHSDigital/dtos-devops-templates
          path: templates
          ref: fix/function-app-acr-is-optional

      - name: AzureCLI login
        if: env.USE_AZURECR == 'true'
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ghcr.io login
        if: env.USE_AZURECR == 'false'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Tag all azurecr.io Docker images
        if: env.USE_AZURECR == 'true'
        run: |
          wait_for_completion() {
            # acr tasks are backgrounded for parallelism
            local -n arr=$1
            for pid in "${arr[@]}"; do
              wait ${pid}
            done
          }
          pids=()
          az acr login --name "${ACR_NAME}"
          repositories=$(az acr repository list --name ${ACR_NAME} --output tsv)
          for repository in ${repositories}; do
            echo "Adding tag ${repository}:${SHORT_COMMIT_HASH}..."
            az acr import --name ${ACR_NAME} --source "${ACR_NAME}.azurecr.io/${repository}:${PR_NUM_TAG}" --image "${repository}:${SHORT_COMMIT_HASH}" --force &
            pids+=($!)
          done
          wait_for_completion pids

      - name: Tag all ghcr.io Docker images
        if: env.USE_AZURECR == 'false'
        env:
          GH_TOKEN: ${{ github.token }}
          REGISTRY: ghcr.io/${{ github.repository_owner }}
        run: |
          packages=$(gh api "/repos/{owner}/{repo}/packages?package_type=container&per_page=100" --jq '.[].name')
          for package in ${packages}; do
            echo "Adding tag ${package}:${SHORT_COMMIT_HASH}..."
            docker buildx imagetools create "${REGISTRY,,}/${package}:${PR_NUM_TAG}" --tag "${REGISTRY,,}/${package}:${SHORT_COMMIT_HASH}" || echo "Tagging failed for $package"
          done

  aggregate-reports:
    runs-on: ubuntu-latest
    needs: build-and-push
    env:
      PR_NUM_TAG: ${{ needs.build-and-push.outputs.pr_num_tag }}
    steps:
      - name: Get all artifacts
        uses: actions/download-artifact@v4
        with:
          path: reports-${{ env.PR_NUM_TAG }}

      - name: Aggregate reports
        uses: actions/upload-artifact@v4
        with:
          name: reports-${{ env.PR_NUM_TAG }}
          path: reports-${{ env.PR_NUM_TAG }}
