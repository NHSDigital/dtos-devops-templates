# This script is implemented in PowerShell since many changes to the Application Gateway resource can be made in a single request
# as compared to Azure CLI which would need many separate and time-consuming updates.
# This script consumes configuration data generated by Terraform, and it requires module AZ.Network version 7.4.0 or greater.
# It is called via a Terraform null resource, and will use existing Azure PowerShell authentication context.
# For this reason Terraform will be launched from within an Azure PowerShell task in Azure DevOps

param (
    [Parameter(Mandatory=$true)]
    [string]$configsJson,
    [Parameter(Mandatory=$true)]
    [string]$appgwName,
    [Parameter(Mandatory=$true)]
    [string]$envCoexistence,
    [Parameter(Mandatory=$true)]
    [ValidateSet("Create", "Destroy")]
    [string]$operationMode
)

$provisioningStateTimeout = 900
$provisioningStateInterval = 5

if (-not (Get-Module -ListAvailable -Name Az)) { Install-Module -Name Az -AllowClobber -Scope CurrentUser -Force -SkipPublisherCheck }
Select-AzSubscription -SubscriptionName $Env:AZURE_SUBSCRIPTION_ID | Out-Null


Function Assert-AppGwProbe {
    param (
        [Parameter(Mandatory=$true)]
        [object]$cfg
    )
    $ProbeParams = @{
        ApplicationGateway                  = $appGateway
        Name                                = $cfg.probe.name
        HostName                            = $cfg.probe.host
        Interval                            = $cfg.probe.interval
        Path                                = $cfg.probe.path
        PickHostNameFromBackendHttpSettings = $cfg.probe.pick_host_name_from_backend_http_settings
        Protocol                            = $cfg.probe.protocol
        Timeout                             = $cfg.probe.timeout
        UnhealthyThreshold                  = $cfg.probe.unhealthy_threshold
        Match                               = New-AzApplicationGatewayProbeHealthResponseMatch -StatusCode ($cfg.probe.match.status_code -join ", ")
    }
    if ($null -eq ($appGateway.Probes | Where-Object {$_.Name -eq $cfg.probe.name})) {
        Write-Host "##[command]Adding Probe $($cfg.probe.name)..."
        Add-AzApplicationGatewayProbeConfig @ProbeParams | Out-Null
    } else {
        Write-Host "##[command]Updating Probe $($cfg.probe.name)..."
        Set-AzApplicationGatewayProbeConfig @ProbeParams | Out-Null
    }
}

Function Assert-AppGwBackendAddressPool {
    param (
        [Parameter(Mandatory=$true)]
        [object]$cfg
    )
    $BackendAddressPoolParams = @{
        ApplicationGateway = $appGateway
        Name               = $cfg.backend_address_pool.name
        BackendIPAddresses = $cfg.backend_address_pool.ip_addresses -join ", "
    }
    if ($null -eq ($appGateway.BackendAddressPools | Where-Object {$_.Name -eq $cfg.backend_address_pool.name})) {
        Write-Host "##[command]Adding Backend Pool $($cfg.backend_address_pool.name)..."
        Add-AzApplicationGatewayBackendAddressPool @BackendAddressPoolParams | Out-Null
    } else {
        Write-Host "##[command]Updating Backend Pool $($cfg.backend_address_pool.name)..."
        Set-AzApplicationGatewayBackendAddressPool @BackendAddressPoolParams | Out-Null
    }
}

Function Assert-AppGwBackendHttpSettings {
    param (
        [Parameter(Mandatory=$true)]
        [object]$cfg
    )
    $BackendHttpSettingsParams = @{
        ApplicationGateway  = $appGateway
        Name                = $cfg.backend_http_settings.name
        CookieBasedAffinity = $cfg.backend_http_settings.cookie_based_affinity
        Probe               = Get-AzApplicationGatewayProbeConfig -ApplicationGateway $appGateway -Name $cfg.backend_http_settings.probe_name
        Port                = $cfg.backend_http_settings.port
        Protocol            = $cfg.backend_http_settings.protocol
        RequestTimeout      = $cfg.backend_http_settings.request_timeout
        ConnectionDraining  = New-AzApplicationGatewayConnectionDraining -Enabled $cfg.backend_http_settings.connection_draining.enabled -DrainTimeoutInSec $cfg.backend_http_settings.connection_draining.drain_timeout_sec
    }
    if ($null -eq ($appGateway.BackendHttpSettingsCollection | Where-Object {$_.Name -eq $cfg.backend_http_settings.name})) {
        Write-Host "##[command]Adding BackendHttpSettings $($cfg.backend_http_settings.name)..."
        Add-AzApplicationGatewayBackendHttpSetting @BackendHttpSettingsParams | Out-Null
    } else {
        Write-Host "##[command]Updating BackendHttpSettings $($cfg.backend_http_settings.name)..."
        Set-AzApplicationGatewayBackendHttpSetting @BackendHttpSettingsParams | Out-Null
    }
}

Function Assert-AppGwHttpListener {
    param (
        [Parameter(Mandatory=$true)]
        [object]$cfg
    )
    $HttpListenerParams = @{
        ApplicationGateway          = $appGateway
        Name                        = $cfg.http_listener.name
        HostNames                   = $cfg.http_listener.host_names -join ", "
        FrontendIPConfiguration     = Get-AzApplicationGatewayFrontendIPConfig -ApplicationGateway $appGateway -Name $cfg.http_listener.frontend_ip_configuration_name
        FrontendPort                = Get-AzApplicationGatewayFrontendPort -ApplicationGateway $appGateway -Name $cfg.http_listener.frontend_port_name
        Protocol                    = $cfg.http_listener.protocol
        RequireServerNameIndication = $cfg.http_listener.require_sni
        SslCertificate              = Get-AzApplicationGatewaySslCertificate -ApplicationGateway $appGateway -Name $cfg.http_listener.ssl_certificate_name
    }
    if ($cfg.http_listener.ssl_profile_name) { # only used for the login listener
        $HttpListenerParams['SslProfile'] = Get-AzApplicationGatewaySslProfile -ApplicationGateway $appGateway -Name $cfg.http_listener.ssl_profile_name
    }
    if ($null -eq ($appGateway.HttpListeners | Where-Object {$_.Name -eq $cfg.http_listener.name})) {
        Write-Host "##[command]Adding HttpListener $($cfg.http_listener.name)..."
        Add-AzApplicationGatewayHttpListener @HttpListenerParams | Out-Null
    } else {
        Write-Host "##[command]Updating HttpListener $($cfg.http_listener.name)..."
        Set-AzApplicationGatewayHttpListener @HttpListenerParams | Out-Null
    }
}

Function Assert-AppGwRequestRoutingRule {
    param (
        [Parameter(Mandatory=$true)]
        [object]$cfg
    )
    $RequestRoutingRuleParams = @{
        ApplicationGateway  = $appGateway
        Name                = $cfg.request_routing_rule.name
        RuleType            = $cfg.request_routing_rule.rule_type
        HttpListener        = Get-AzApplicationGatewayHttpListener -ApplicationGateway $appGateway -Name $cfg.request_routing_rule.http_listener_name
        BackendAddressPool  = Get-AzApplicationGatewayBackendAddressPool -ApplicationGateway $appGateway -Name $cfg.request_routing_rule.backend_address_pool_name
        BackendHttpSettings = Get-AzApplicationGatewayBackendHttpSetting -ApplicationGateway $appGateway -Name $cfg.request_routing_rule.backend_http_settings_name
        Priority            = $cfg.request_routing_rule.priority
    }

    if ($null -eq ($appGateway.RequestRoutingRules | Where-Object {$_.Name -eq $cfg.request_routing_rule.name})) {
        Write-Host "##[command]Adding RequestRoutingRule $($cfg.request_routing_rule.name)..."
        Add-AzApplicationGatewayRequestRoutingRule @RequestRoutingRuleParams | Out-Null
    } else {
        Write-Host "##[command]Updating RequestRoutingRule $($cfg.request_routing_rule.name)..."
        Set-AzApplicationGatewayRequestRoutingRule @RequestRoutingRuleParams | Out-Null
    }
}

Function Get-AppGwReadiness {
    $appGatewayIsReady = $false
    $timeElapsed = 0
    Write-Host "##[command]Waiting for Application Gateway ${appgwName} to become writeable"
    if ((Get-AzApplicationGateway -Name $appgwName -ResourceGroupName $appgwRgName).ProvisioningState -ne "Succeeded") {
        do {
            $appGatewayIsReady = (Get-AzApplicationGateway -Name $appgwName -ResourceGroupName $appgwRgName).ProvisioningState -eq "Succeeded"
            Start-Sleep -Seconds $provisioningStateInterval
            $timeElapsed += $provisioningStateInterval
            Write-Host "##[command]Still waiting. Time elapsed $timeElapsed"
        }
        until ($timeElapsed -gt $provisioningStateTimeout -or $appGatewayIsReady -eq $true)
    } else {
        $appGatewayIsReady = $true
    }
    if (-not $appGatewayIsReady) {
        $lastProvisioningState = (Get-AzApplicationGateway -Name $appgwName -ResourceGroupName $appgwRgName).ProvisioningState
        Write-Host "##vso[task.logissue type=error]Timeout while waiting for ${appgwName} to become ready for changes. Last ProvisioningState was $lastProvisioningState"
        exit 1
    }
}



$configList = $configsJson | ConvertFrom-Json

# If no coexistence, assume each K8s cluster defined in the current .tfvars file will join the same Application Gateway config
# Ensure bool from Terraform is converted to the PowerShell $true and $false
if (-not [bool]::Parse($envCoexistence)) {
    $firstConfigsOnly = @()

    # Find only the first instance of each config type and add it to the list
    $configTypes = $configList | Select-Object -ExpandProperty config_type -Unique
    foreach ($type in $configTypes) {
        $firstConfigOfType = $configList | Where-Object { $_.config_type -eq $type } | Select-Object -First 1
        $firstConfigsOnly += $firstConfigOfType
    }
    $configList = $firstConfigsOnly
}

$appgwRgName   = $configList[0].appgw_rg_name
Get-AppGwReadiness
$appGateway    = Get-AzApplicationGateway -Name $appgwName -ResourceGroupName $appgwRgName
$commonConfigs = $configList | Where-Object { $_.config_type -eq 'common' }
$otherConfigs  = $configList | Where-Object { $_.config_type -ne 'common' }

if ($operationMode -eq "Create") { # deploy in dependency order
    foreach ($configItem in $commonConfigs) { # re-used backend definitions, must deploy first
        Assert-AppGwProbe -cfg $configItem.config_data
        Assert-AppGwBackendAddressPool -cfg $configItem.config_data
        Assert-AppGwBackendHttpSettings -cfg $configItem.config_data
    }
    foreach ($configItem in $otherConfigs) {
        if ($configItem.config_type -eq "login" -or $configItem.config_type -eq "default") { # cid rule or wildcard rule
            Assert-AppGwHttpListener -cfg $configItem.config_data
            Assert-AppGwRequestRoutingRule -cfg $configItem.config_data
        } elseif ($configItem.config_type -eq "default_private") {
            Assert-AppGwProbe-cfg $configItem.config_data
            Assert-AppGwBackendHttpSettings -cfg $configItem.config_data
            Assert-AppGwHttpListener -cfg $configItem.config_data
            Assert-AppGwRequestRoutingRule -cfg $configItem.config_data
        }
    }
    Write-Host "##[command]Asserting configuration on Application Gateway ${appgwName}..."
}

elseif ($operationMode -eq "Destroy") { # destroy in reverse dependency order, removing non-existent objects does not throw errors
    foreach ($configItem in $otherConfigs) {
        if ($configItem.config_type -eq "default_private") {
            Remove-AzApplicationGatewayRequestRoutingRule -ApplicationGateway $appGateway -Name $configItem.config_data.request_routing_rule.name | Out-Null
            Remove-AzApplicationGatewayHttpListener -ApplicationGateway $appGateway -Name $configItem.config_data.http_listener.name | Out-Null
            Remove-AzApplicationGatewayBackendHttpSetting -ApplicationGateway $appGateway -Name $configItem.config_data.backend_http_settings.name | Out-Null
            Remove-AzApplicationGatewayProbeConfig -ApplicationGateway $appGateway -Name $configItem.config_data.probe.name | Out-Null
        } elseif ($configItem.config_type -eq "login" -or $configItem.config_type -eq "default") { # cid rule or wildcard rule
            Remove-AzApplicationGatewayRequestRoutingRule -ApplicationGateway $appGateway -Name $configItem.config_data.request_routing_rule.name | Out-Null
            Remove-AzApplicationGatewayHttpListener -ApplicationGateway $appGateway -Name $configItem.config_data.http_listener.name | Out-Null
        }
    }
    foreach ($configItem in $commonConfigs) { # re-used backend definitions, must destroy last
        Remove-AzApplicationGatewayBackendHttpSetting -ApplicationGateway $appGateway -Name $configItem.config_data.backend_http_settings.name | Out-Null
        Remove-AzApplicationGatewayBackendAddressPool -ApplicationGateway $appGateway -Name $configItem.config_data.backend_address_pool.name | Out-Null
        Remove-AzApplicationGatewayProbeConfig -ApplicationGateway $appGateway -Name $configItem.config_data.probe.name | Out-Null
    }
    Write-Host "##[command]Destroying configuration on Application Gateway ${appgwName}..."
}

Set-AzApplicationGateway -ApplicationGateway $appGateway | Out-Null
if ($?) {
    Write-Host "##vso[task.complete result=Succeeded;]Application Gateway ${appgwName} updated..."
} else {
    Write-Host "##vso[task.logissue type=error]Application Gateway ${appgwName} could not be updated..."
}
